#include "encoder.h"

#include <fstream>

#include "string_util.h"

void EncodeBuffer::push(const std::string& token)
{
	if (m_lines.empty())
	{
		m_lines.push_back(token);
	}
	else
	{
		m_lines[m_lines.size() - 1] += token;
	}
}

void EncodeBuffer::push_line(const std::string& line)
{
	m_lines.push_back(line);
}

std::string EncodeBuffer::string() const
{
	std::string content;
	for (const std::string& line : m_lines)
	{
		content += line + "\n";
	}
	return content;
}

bool Encoder::encode(const TypeCollection& collection, const SymbolTable& symbolTable, const std::filesystem::path& path, const std::string& filename)
{
	static const auto read = [](const std::filesystem::path& filename) -> std::string
	{
		std::ostringstream buf;
		std::ifstream input(filename.c_str());
		buf << input.rdbuf();
		return buf.str();
	};

	std::filesystem::path outHeaderFilename = path / StringUtil::replace(filename, ".h", "_generated.h");
	std::filesystem::path outSourceFilename = path / StringUtil::replace(filename, ".h", "_generated.cpp");

	EncodeBuffer header_buffer;
	header_buffer.push_line("// Copyright (c) Vito Domenico Tagliente");
	header_buffer.push_line("// automatically generated by the compiler, do not modify");
	header_buffer.push_line("#pragma once");
	header_buffer.push_line("");
	header_buffer.push_line("#include <vdtreflect/runtime.h>");
	header_buffer.push_line("");

	EncodeBuffer source_buffer;
	source_buffer.push_line("// Copyright (c) Vito Domenico Tagliente");
	source_buffer.push_line("// automatically generated by the compiler, do not modify");
	source_buffer.push_line("#include \"", filename, "\"");
	source_buffer.push_line("");

	// enums
	for (Type* const entity : collection.m_entities)
	{
		if (TypeEnum* const eEnum = dynamic_cast<TypeEnum*>(entity))
		{
			if (!encode(header_buffer, source_buffer, symbolTable, *eEnum))
			{
				return false;
			}
		}
	}

	// classes
	for (Type* const entity : collection.m_entities)
	{
		if (TypeClass* const eClass = dynamic_cast<TypeClass*>(entity))
		{
			if (!encode(header_buffer, source_buffer, symbolTable, *eClass))
			{
				return false;
			}
		}
	}

	static const auto& generate = [](const EncodeBuffer& buffer, const std::string& filename) -> bool
	{
		std::string previousContent;
		std::string content = buffer.string();

		if (std::filesystem::exists(filename))
		{
			previousContent = read(filename);
		}

		if (previousContent != content)
		{
			std::ofstream fstream(filename);
			if (!fstream.is_open())
			{
				return false;
			}
			fstream << content;
			fstream.close();
		}
		return true;
	};

	// generate the header file only if it is changed or if it doesn't exist
	if (!generate(header_buffer, outHeaderFilename.string())) return false;
	// generate the source file only if it is changed or if it doesn't exist
	if (!generate(source_buffer, outSourceFilename.string())) return false;

	return true;
}

bool Encoder::encode(EncodeBuffer& headerBuffer, EncodeBuffer& sourceBuffer, const SymbolTable& symbolTable, TypeClass& type)
{
	// header
	headerBuffer.push_line("struct __", type.name, "Type : RegisteredInTypeFactory<__", type.name, "Type>");
	headerBuffer.push_line("{");
	headerBuffer.push_line("    __", type.name, "Type() = delete;");
	headerBuffer.push_line("");
	headerBuffer.push_line("    static const TypeDefinition& type();");
	headerBuffer.push_line("    static bool registered() { return value; };");
	headerBuffer.push_line("};");
	headerBuffer.push_line("");

	// source
	sourceBuffer.push_line("const meta_t& ", type.name, "::getTypeMeta() const { return __", type.name, "Type::type().meta; }");
	sourceBuffer.push_line("const std::string& ", type.name, "::getTypeName() const { return __", type.name, "Type::type().name; }");
	sourceBuffer.push_line("const properties_t ", type.name, "::getTypeProperties() const {");
	if (!type.properties.empty())
	{
		sourceBuffer.push_line("    member_address_t origin = reinterpret_cast<member_address_t>(this);");
	}
	if (type.parent != "Type")
	{
		sourceBuffer.push_line("    properties_t properties = ", type.parent, "::getTypeProperties();");
	}
	else
	{
		sourceBuffer.push_line("    properties_t properties;");
	}
	for (const Property& property : type.properties)
	{
		sourceBuffer.push_line(encode(symbolTable, type.name, "    ", property));
	}
	sourceBuffer.push_line("    return properties;");
	sourceBuffer.push_line("}");
	sourceBuffer.push_line("std::size_t ", type.name, "::getTypeSize() const { return __", type.name, "Type::type().size; }");
	sourceBuffer.push_line("");
	sourceBuffer.push_line("const TypeDefinition& __", type.name, "Type::type()");
	sourceBuffer.push_line("{");
	sourceBuffer.push_line("    static const TypeDefinition s_typeDefinition([]() -> Type* { return new ", type.name, "(); }, \"", type.name, "\", {");
	for (const auto& [key, value] : type.meta)
	{
		sourceBuffer.push_line("        std::make_pair(\"", key, "\", \"", value, "\"),");
	}
	sourceBuffer.push_line("    }, sizeof(", type.name, "));");
	sourceBuffer.push_line("    return s_typeDefinition;");
	sourceBuffer.push_line("}");

	return true;
}

bool Encoder::encode(EncodeBuffer& headerBuffer, EncodeBuffer& sourceBuffer, const SymbolTable& symbolTable, TypeEnum& type)
{
	// header
	headerBuffer.push_line("template <>");
	headerBuffer.push_line("struct EnumType<enum class ", type.name, ">");
	headerBuffer.push_line("{");
	headerBuffer.push_line("    static const char* name();");
	headerBuffer.push_line("    static const  enum_values_t& values();");
	headerBuffer.push_line("};");
	headerBuffer.push_line("");
	headerBuffer.push_line("struct __", type.name, "Enum : RegisteredInEnumFactory<enum class ", type.name, ">");
	headerBuffer.push_line("{");
	headerBuffer.push_line("    static bool registered() { return value; };");
	headerBuffer.push_line("};");
	headerBuffer.push_line("");

	// source
	sourceBuffer.push_line("const char* EnumType<", type.name, ">::name() { return \"", type.name, "\"; }");
	sourceBuffer.push_line("const enum_values_t& EnumType<", type.name, ">::values()");
	sourceBuffer.push_line("{");
	sourceBuffer.push_line("    static enum_values_t s_values{");
	for (const std::string& option : type.options)
	{
		sourceBuffer.push_line("        { \"", option, "\", static_cast<int>(", type.name, "::", option, ") }, ");
	}
	sourceBuffer.push_line("    };");
	sourceBuffer.push_line("    return s_values;");
	sourceBuffer.push_line("}");
	sourceBuffer.push_line("");

	return true;
}

std::string Encoder::encode(const SymbolTable& symbolTable, const std::string& name, const std::string& offset, const Property& property)
{
	std::string content = (offset + "properties.insert(std::make_pair<std::string, Property>(\"" + property.name + "\", Property(\"" + property.name + "\", " +
		encode(symbolTable, property.type) +
		", sizeof(" + property.type + "), origin + offsetof(" + name + ", " + property.name + "), {\n");
	for (const auto& [key, value] : property.meta)
	{
		content += (offset + "    std::make_pair(\"" + key + "\", \"" + value + "\"),\n");
	}
	content += (offset + "})));");
	return content;
}

std::string Encoder::encode(const SymbolTable& symbolTable, const std::string& token)
{
	std::string type = token;
	const std::string decoratorType = encodeToDecoratorTypeEnum(symbolTable, type);
	std::vector<std::string> typenames; 
	std::string children;

	if (decoratorType == "Property::DecoratorType::D_shared_ptr"
		|| decoratorType == "Property::DecoratorType::D_unique_ptr"
		|| decoratorType == "Property::DecoratorType::D_weak_ptr")
	{
		type = sanitizeTemplate(type);
	}
	else
	{
		typenames = extractTypenames(type);
		for (const std::string& tname : typenames)
		{
			children += (children.empty() ? "" : ", ") + encode(symbolTable, tname);
		}
	}
	
	return ("Property::TypeDescriptor(\"" + type + "\", " + encodeToTypeEnum(symbolTable, type) + ", " + decoratorType + ", {" + children + "})");
}

std::string Encoder::encodeToTypeEnum(const SymbolTable& symbolTable, const std::string& t)
{
	std::string type = StringUtil::replace(t, "std::", "");
	if (type.empty()) return "PropertyType::T_unknown";

	while (!type.empty() && (type[type.length() - 1] == '*' || type[type.length() - 1] == '&' || type[type.length() - 1] == ' '))
	{
		type.pop_back();
	}

	if (type == "bool") return "Property::Type::T_bool";
	if (type == "char") return "Property::Type::T_char";
	if (type == "double") return "Property::Type::T_double";
	if (type == "float") return "Property::Type::T_float";
	if (type == "int") return "Property::Type::T_int";
	if (type == "void") return "Property::Type::T_void";
	if (type == "string") return "Property::Type::T_container_string";
	if (StringUtil::startsWith(type, "map<")) return "Property::Type::T_container_map";
	if (StringUtil::startsWith(type, "vector<")) return "Property::Type::T_container_vector";

	const auto& it = symbolTable.find(type);
	if (it != symbolTable.end())
	{
		switch (it->second)
		{
		case SymbolType::S_class: return "Property::Type::T_custom_type";
		case SymbolType::S_enum: return "Property::Type::T_custom_enum";
		default: return "Property::Type::T_unknown";
		}
	}

	return "Property::Type::T_unknown";
}

std::string Encoder::encodeToDecoratorTypeEnum(const SymbolTable& symbolTable, const std::string& t)
{
	std::string type = StringUtil::replace(t, "std::", "");

	if (StringUtil::endsWith(type, "*")) return "Property::DecoratorType::D_pointer";
	if (StringUtil::endsWith(type, "&")) return "Property::DecoratorType::D_reference";
	if (StringUtil::startsWith(type, "shared_ptr")) return "Property::DecoratorType::D_shared_ptr";
	if (StringUtil::startsWith(type, "unique_ptr")) return "Property::DecoratorType::D_unique_ptr";
	if (StringUtil::startsWith(type, "weak_ptr")) return "Property::DecoratorType::D_weak_ptr";
	return "Property::DecoratorType::D_normalized";
}

std::vector<std::string> Encoder::extractTypenames(const std::string& token)
{
	std::vector<std::string> typenames;
	const size_t startIndex = token.find('<');
	if (startIndex == std::string::npos) return typenames;

	if (token.back() != '>') return typenames;

	std::string content = token.substr(startIndex + 1, token.length());
	content.pop_back();

	for (std::string t : StringUtil::split(content, ','))
	{
		typenames.push_back(StringUtil::trim(t));
	}
	return typenames;
}

std::string Encoder::sanitizeTemplate(const std::string& token)
{
	const size_t startIndex = token.find('<');
	if (startIndex == std::string::npos) return token;

	if (token.back() != '>') return token;

	std::string content = token.substr(startIndex + 1, token.length());
	content.pop_back();

	return content;
}
