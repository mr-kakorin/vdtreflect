#include "encoder.h"

#include <fstream>

#include "string_util.h"

void EncodeBuffer::push(const std::string& token)
{
	if (m_lines.empty())
	{
		m_lines.push_back(token);
	}
	else
	{
		m_lines[m_lines.size() - 1] += token;
	}
}

void EncodeBuffer::push_line(const std::string& line)
{
	m_lines.push_back(line);
}

bool Encoder::encode(TypeCollection& collection, const std::filesystem::path& path, const std::string& filename)
{
	std::filesystem::path outHeaderFilename = path / StringUtil::replace(filename, ".h", "_generated.h");
	std::filesystem::path outSourceFilename = path / StringUtil::replace(filename, ".h", "_generated.cpp");

	EncodeBuffer header_buffer;
	header_buffer.push_line("// Copyright (c) Vito Domenico Tagliente");
	header_buffer.push_line("// automatically generated by the compiler, do not modify");
	header_buffer.push_line("#pragma once");
	header_buffer.push_line("");
	header_buffer.push_line("#include <vdtreflect/runtime.h>");
	header_buffer.push_line("");

	EncodeBuffer source_buffer;
	source_buffer.push_line("// Copyright (c) Vito Domenico Tagliente");
	source_buffer.push_line("// automatically generated by the compiler, do not modify");
	source_buffer.push_line("#include \"", filename, "\"");
	source_buffer.push_line("");

	// enums
	for (const auto& entity : collection.m_entities)
	{
		Type* const e = entity.get();
		if (TypeEnum* const eEnum = dynamic_cast<TypeEnum*>(e))
		{
			if (!encode(header_buffer, source_buffer, *eEnum))
			{
				return false;
			}
		}
	}

	// classes
	for (const auto& entity : collection.m_entities)
	{
		Type* const e = entity.get();
		if (TypeClass* const eClass = dynamic_cast<TypeClass*>(e))
		{
			if (!encode(header_buffer, source_buffer, *eClass))
			{
				return false;
			}
		}
	}

	// generate the header file
	{
		std::ofstream fstream(outHeaderFilename);
		if (!fstream.is_open())
		{
			return false;
		}

		for (const std::string& line : header_buffer.m_lines)
		{
			fstream << line << "\n";
		}
		fstream.close();
	}

	// generate the imp file
	{
		std::ofstream fstream(outSourceFilename);
		if (!fstream.is_open())
		{
			return false;
		}

		for (const std::string& line : source_buffer.m_lines)
		{
			fstream << line << "\n";
		}
		fstream.close();
	}

	return true;
}

bool Encoder::encode(EncodeBuffer& headerBuffer, EncodeBuffer& sourceBuffer, TypeClass& type)
{
	// header
	headerBuffer.push_line("struct ", type.name, "Type : RegisteredInTypeFactory<", type.name, "Type>");
	headerBuffer.push_line("{");
	headerBuffer.push_line("    ", type.name, "Type() = delete;");
	headerBuffer.push_line("");
	headerBuffer.push_line("    static const Type& type();");
	headerBuffer.push_line("    static bool registered() { return value; };");
	headerBuffer.push_line("};");
	headerBuffer.push_line("");

	// source
	sourceBuffer.push_line("const meta_t& ", type.name, "::getTypeMeta() const { return ", type.name, "Type::type().meta; }");
	sourceBuffer.push_line("const std::string& ", type.name, "::getTypeName() const { return ", type.name, "Type::type().name; }");
	sourceBuffer.push_line("const properties_t ", type.name, "::getTypeProperties() const {");
	if (!type.properties.empty())
	{
		sourceBuffer.push_line("    member_address_t origin = reinterpret_cast<member_address_t>(this);");
	}
	if (type.parent != "IType")
	{
		sourceBuffer.push_line("    properties_t properties = ", type.parent, "::getTypeProperties();");
	}
	else
	{
		sourceBuffer.push_line("    properties_t properties;");
	}
	for (const Property& prop : type.properties)
	{
		sourceBuffer.push_line("    properties.insert(std::make_pair<std::string, Property>(\"", prop.name, "\", Property(\"", prop.name, "\", ", encodeToTypeEnum(prop),
			", \"", prop.type, "\", ", encodeIsNormalType(prop.type), ", sizeof(", prop.type, "), origin + offsetof(", type.name, ", ", prop.name, "), {");
		for (const auto& [key, value] : prop.meta)
		{
			sourceBuffer.push_line("        std::make_pair(\"", key, "\", \"", value, "\"),");
		}
		sourceBuffer.push_line("    })));");
	}
	sourceBuffer.push_line("    return properties;");
	sourceBuffer.push_line("}");
	sourceBuffer.push_line("std::size_t ", type.name, "::getTypeSize() const { return ", type.name, "Type::type().size; }");
	sourceBuffer.push_line("");
	sourceBuffer.push_line("const Type& ", type.name, "Type::type()");
	sourceBuffer.push_line("{");
	sourceBuffer.push_line("    static const Type s_type([]() -> IType* { return new ", type.name, "(); }, \"", type.name, "\", {");
	for (const auto& [key, value] : type.meta)
	{
		sourceBuffer.push_line("        std::make_pair(\"", key, "\", \"", value, "\"),");
	}
	sourceBuffer.push_line("    }, sizeof(", type.name, "));");
	sourceBuffer.push_line("    return s_type;");
	sourceBuffer.push_line("}");

	return true;
}

bool Encoder::encode(EncodeBuffer& headerBuffer, EncodeBuffer& sourceBuffer, TypeEnum& type)
{
	// header
	headerBuffer.push_line("template <>");
	headerBuffer.push_line("struct EnumType<enum class ", type.name, ">");
	headerBuffer.push_line("{");
	headerBuffer.push_line("    static const char* name();");
	headerBuffer.push_line("    static const std::map<const char*, int> values();");
	headerBuffer.push_line("};");
	headerBuffer.push_line("");

	// source
	sourceBuffer.push_line("const char* EnumType<", type.name, ">::name() { return \"", type.name, "\"; }");
	sourceBuffer.push_line("const std::map<const char*, int>  EnumType<", type.name, ">::values()");
	sourceBuffer.push_line("{");
	sourceBuffer.push_line("    static std::map<const char*, int> s_values{");
	for (const std::string& option : type.options)
	{
		sourceBuffer.push_line("        { \"", option, "\", static_cast<int>(", type.name, "::", option, ") }, ");
	}
	sourceBuffer.push_line("    };");
	sourceBuffer.push_line("    return s_values;");
	sourceBuffer.push_line("}");
	sourceBuffer.push_line("");

	return true;
}

std::string Encoder::encodeToTypeEnum(const Property& prop)
{
	std::string type = prop.type;
	if (type.empty()) return "PropertyType::T_unknown";

	while (!type.empty() && (type[type.length() - 1] == '*' || type[type.length() - 1] == '&' || type[type.length() - 1] == ' '))
	{
		type.pop_back();
	}

	if (prop.type == "bool") return "PropertyType::T_bool";
	if (prop.type == "char") return "PropertyType::T_char";
	if (prop.type == "double") return "PropertyType::T_double";
	if (prop.type == "float") return "PropertyType::T_float";
	if (prop.type == "int") return "PropertyType::T_int";
	if (prop.type == "void") return "PropertyType::T_void";
	if (prop.type == "std::array" || prop.type == "array") return "PropertyType::T_container_array";
	if (prop.type == "std::list" || prop.type == "list") return "PropertyType::T_container_list";
	if (prop.type == "std::map" || prop.type == "map") return "PropertyType::T_container_map";
	if (prop.type == "std::queue" || prop.type == "queue") return "PropertyType::T_container_queue";
	if (prop.type == "std::set" || prop.type == "set") return "PropertyType::NT_container_set";
	if (prop.type == "std::stack" || prop.type == "stack") return "PropertyType::T_container_stack";
	if (prop.type == "std::string" || prop.type == "string") return "PropertyType::T_container_string";
	if (prop.type == "std::vector" || prop.type == "vector") return "PropertyType::T_container_vector";
	if (prop.type == "std::unordered_map" || prop.type == "unordered_map") return "PropertyType::T_container_unordered_map";
	if (prop.meta.find("IsEnum") != prop.meta.end()) return "PropertyType::T_custom_enum";
	if (prop.meta.find("IsType") != prop.meta.end()) return "PropertyType::T_custom_type";
	return "PropertyType::T_unknown";
}

std::string Encoder::encodeIsNormalType(const std::string& type)
{
	if (StringUtil::contains(type, "*") || StringUtil::contains(type, "&")) return "false";
	return "true";
}
