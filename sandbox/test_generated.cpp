// Copyright (c) Vito Domenico Tagliente
// automatically generated by the compiler, do not modify
#include "test.h"

const char* EnumType<TestEnum>::name() { return "TestEnum"; }
const std::map<const char*, int>  EnumType<TestEnum>::values()
{
    static std::map<const char*, int> s_values{
        { "A", static_cast<int>(TestEnum::A) }, 
        { "B", static_cast<int>(TestEnum::B) }, 
    };
    return s_values;
}

const char* EnumType<ApplicationMode>::name() { return "ApplicationMode"; }
const std::map<const char*, int>  EnumType<ApplicationMode>::values()
{
    static std::map<const char*, int> s_values{
        { "Editor", static_cast<int>(ApplicationMode::Editor) }, 
        { "Server", static_cast<int>(ApplicationMode::Server) }, 
        { "Standalone", static_cast<int>(ApplicationMode::Standalone) }, 
    };
    return s_values;
}

const meta_t& Foo::getTypeMeta() const { return FooType::type().meta; }
const std::string& Foo::getTypeName() const { return FooType::type().name; }
const properties_t Foo::getTypeProperties() const {
    member_address_t origin = reinterpret_cast<member_address_t>(this);
    properties_t properties;
    properties.insert(std::make_pair<std::string, Property>("a", Property("a", NativeType::NT_int, "int", sizeof(int), origin + offsetof(Foo, a), {
        std::make_pair("JsonExport", "true"),
    })));
    properties.insert(std::make_pair<std::string, Property>("b", Property("b", NativeType::NT_int, "int", sizeof(int), origin + offsetof(Foo, b), {
    })));
    return properties;
}
std::size_t Foo::getTypeSize() const { return FooType::type().size; }

const Type& FooType::type()
{
    static const Type s_type([]() -> IType* { return new Foo(); }, "Foo", {
        std::make_pair("Category", "MyClass"),
        std::make_pair("Serializable", "true"),
    }, sizeof(Foo));
    return s_type;
}
const meta_t& Poo::getTypeMeta() const { return PooType::type().meta; }
const std::string& Poo::getTypeName() const { return PooType::type().name; }
const properties_t Poo::getTypeProperties() const {
    member_address_t origin = reinterpret_cast<member_address_t>(this);
    properties_t properties = Foo::getTypeProperties();
    properties.insert(std::make_pair<std::string, Property>("c", Property("c", NativeType::NT_int, "int", sizeof(int), origin + offsetof(Poo, c), {
    })));
    return properties;
}
std::size_t Poo::getTypeSize() const { return PooType::type().size; }

const Type& PooType::type()
{
    static const Type s_type([]() -> IType* { return new Poo(); }, "Poo", {
    }, sizeof(Poo));
    return s_type;
}
