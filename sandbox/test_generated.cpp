// Copyright (c) Vito Domenico Tagliente
// automatically generated by the compiler, do not modify
#include "test.h"

const char* const reflect::Enum<TestEnum>::name() { return "TestEnum"; }
const reflect::enum_values_t& reflect::Enum<TestEnum>::values()
{
    static reflect::enum_values_t s_values{
        { "A", static_cast<int>(TestEnum::A) }, 
        { "B", static_cast<int>(TestEnum::B) }, 
    };
    return s_values;
}

const char* const reflect::Enum<ApplicationMode>::name() { return "ApplicationMode"; }
const reflect::enum_values_t& reflect::Enum<ApplicationMode>::values()
{
    static reflect::enum_values_t s_values{
        { "Editor", static_cast<int>(ApplicationMode::Editor) }, 
        { "Server", static_cast<int>(ApplicationMode::Server) }, 
        { "Standalone", static_cast<int>(ApplicationMode::Standalone) }, 
    };
    return s_values;
}

const reflect::meta_t& reflect::Type<Foo>::meta()
{
    static reflect::meta_t s_meta {
        { "Category", "MyClass" },
        { "Serializable", "true" },
    };
    return s_meta;
}
const char* const reflect::Type<Foo>::name() { return "Foo"; }

const reflect::properties_t& Type<Foo>::properties()
{
    static reflect::properties_t s_properties {
        { "a", reflect::Property{ offsetof(Foo, a), reflect::meta_t {{"JsonExport", "true"} }, "a", reflect::NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int } } },
        { "b", reflect::Property{ offsetof(Foo, b), reflect::meta_t { }, "b", reflect::NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int } } },
        { "enabled", reflect::Property{ offsetof(Foo, enabled), reflect::meta_t { }, "enabled", reflect::NativeType{ "bool", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(bool), reflect::NativeType::Type::T_bool } } },
    };
    return s_properties;
}

const reflect::meta_t& Foo::type_meta() const { return reflect::Type<Foo>::meta(); }
const char* const Foo::type_name() const { return reflect::Type<Foo>::name(); }
const reflect::properties_t& Foo::type_properties() const { return reflect::Type<Foo>::properties(); }

Foo::operator std::string() const
{
    reflect::encoding::ByteBuffer buffer;
    reflect::encoding::OutputByteStream stream(buffer);
    stream << type_name();
    
    stream << a;
    stream << b;
    stream << enabled;
    
    return std::string(reinterpret_cast<const char*>(&stream.getBuffer()[0]), stream.getBuffer().size());
}

void Foo::from_string(const std::string& str)
{
    reflect::encoding::ByteBuffer buffer;
    std::transform(
        std::begin(str),
        std::end(str),
        std::back_inserter(buffer),
        [](const char c)
        {
            return std::byte(c);
        }
    );
    
    reflect::encoding::InputByteStream stream(buffer);
    std::string _name;
    stream >> _name;
    if (_name != type_name()) return;
    
    stream >> a;
    stream >> b;
    stream >> enabled;
}

void Foo::from_json(const std::string& json)
{
}

std::string Foo::to_json() const
{
    reflect::encoding::StringBuffer buffer;
    buffer.push_line("{");
    buffer.push_line("    \"a\": ", a, ",");
    buffer.push_line("    \"b\": ", b, ",");
    buffer.push_line("    \"enabled\": ", enabled ? "true" : "false", ",");
    buffer.push_line("}");
    return buffer.string();
}

const reflect::meta_t& reflect::Type<Poo>::meta()
{
    static reflect::meta_t s_meta {
    };
    return s_meta;
}
const char* const reflect::Type<Poo>::name() { return "Poo"; }

const reflect::properties_t& Type<Poo>::properties()
{
    static reflect::properties_t s_properties {
        // Parent class Foo properties
        { "a", reflect::Property{ offsetof(Poo, a), reflect::meta_t {{"JsonExport", "true"} }, "a", reflect::NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int } } },
        { "b", reflect::Property{ offsetof(Poo, b), reflect::meta_t { }, "b", reflect::NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int } } },
        { "enabled", reflect::Property{ offsetof(Poo, enabled), reflect::meta_t { }, "enabled", reflect::NativeType{ "bool", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(bool), reflect::NativeType::Type::T_bool } } },
        // Properties
        { "c", reflect::Property{ offsetof(Poo, c), reflect::meta_t { }, "c", reflect::NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int } } },
        { "numbers", reflect::Property{ offsetof(Poo, numbers), reflect::meta_t { }, "numbers", reflect::NativeType{ "std::vector<int>", { 
            reflect::NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int },
        }, reflect::NativeType::DecoratorType::D_raw, sizeof(std::vector<int>), reflect::NativeType::Type::T_template } } },
        { "list", reflect::Property{ offsetof(Poo, list), reflect::meta_t { }, "list", reflect::NativeType{ "std::list<int>", { 
            reflect::NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int },
        }, reflect::NativeType::DecoratorType::D_raw, sizeof(std::list<int>), reflect::NativeType::Type::T_template } } },
        { "dictionary", reflect::Property{ offsetof(Poo, dictionary), reflect::meta_t { }, "dictionary", reflect::NativeType{ "std::map<std::string, int>", { 
            reflect::NativeType{ "std::string", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(std::string), reflect::NativeType::Type::T_string },
            reflect::NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int },
        }, reflect::NativeType::DecoratorType::D_raw, sizeof(std::map<std::string, int>), reflect::NativeType::Type::T_template } } },
        { "tuple", reflect::Property{ offsetof(Poo, tuple), reflect::meta_t { }, "tuple", reflect::NativeType{ "std::tuple<int, float, bool, double>", { 
            reflect::NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int },
            reflect::NativeType{ "float", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(float), reflect::NativeType::Type::T_float },
            reflect::NativeType{ "bool", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(bool), reflect::NativeType::Type::T_bool },
            reflect::NativeType{ "double", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(double), reflect::NativeType::Type::T_double },
        }, reflect::NativeType::DecoratorType::D_raw, sizeof(std::tuple<int, float, bool, double>), reflect::NativeType::Type::T_template } } },
        { "power_dictionary", reflect::Property{ offsetof(Poo, power_dictionary), reflect::meta_t { }, "power_dictionary", reflect::NativeType{ "std::map<std::string, std::vector<int>>", { 
            reflect::NativeType{ "std::string", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(std::string), reflect::NativeType::Type::T_string },
            reflect::NativeType{ "std::vector<int>", { 
                reflect::NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int },
            }, reflect::NativeType::DecoratorType::D_raw, sizeof(std::vector<int>), reflect::NativeType::Type::T_template },
        }, reflect::NativeType::DecoratorType::D_raw, sizeof(std::map<std::string, std::vector<int>>), reflect::NativeType::Type::T_template } } },
        { "e", reflect::Property{ offsetof(Poo, e), reflect::meta_t { }, "e", reflect::NativeType{ "TestEnum", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(TestEnum), reflect::NativeType::Type::T_enum } } },
        { "type", reflect::Property{ offsetof(Poo, type), reflect::meta_t { }, "type", reflect::NativeType{ "Foo", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(Foo), reflect::NativeType::Type::T_type } } },
    };
    return s_properties;
}

const reflect::meta_t& Poo::type_meta() const { return reflect::Type<Poo>::meta(); }
const char* const Poo::type_name() const { return reflect::Type<Poo>::name(); }
const reflect::properties_t& Poo::type_properties() const { return reflect::Type<Poo>::properties(); }

Poo::operator std::string() const
{
    reflect::encoding::ByteBuffer buffer;
    reflect::encoding::OutputByteStream stream(buffer);
    stream << type_name();
    
    // Parent class Foo properties
    stream << a;
    stream << b;
    stream << enabled;
    // Properties
    stream << c;
    {
        stream << numbers.size();
        for (const auto& element : numbers)
        {
            stream << element;
        }
    }
    {
        stream << list.size();
        for (const auto& element : list)
        {
            stream << element;
        }
    }
    {
        stream << dictionary.size();
        for (const auto& pair : dictionary)
        {
            stream << pair.first;
            stream << pair.second;
        }
    }
    stream << static_cast<int>(e);
    stream << static_cast<std::string>(type);
    
    return std::string(reinterpret_cast<const char*>(&stream.getBuffer()[0]), stream.getBuffer().size());
}

void Poo::from_string(const std::string& str)
{
    reflect::encoding::ByteBuffer buffer;
    std::transform(
        std::begin(str),
        std::end(str),
        std::back_inserter(buffer),
        [](const char c)
        {
            return std::byte(c);
        }
    );
    
    reflect::encoding::InputByteStream stream(buffer);
    std::string _name;
    stream >> _name;
    if (_name != type_name()) return;
    
    // Parent class Foo properties
    stream >> a;
    stream >> b;
    stream >> enabled;
    // Properties
    stream >> c;
    {
        std::size_t size;
        stream >> size;
        numbers.resize(size);
        for (int i = 0; i < numbers.size(); ++i)
        {
            int element;
            stream >> element;
            numbers.push_back(element);
        }
    }
    {
        std::size_t size;
        stream >> size;
        list.resize(size);
        for (int i = 0; i < list.size(); ++i)
        {
            int element;
            stream >> element;
            list.push_back(element);
        }
    }
    {
        std::size_t size;
        stream >> size;
        for (int i = 0; i < size; ++i)
        {
            std::string key;
            stream >> key;
            int value;
            stream >> value;
            dictionary.insert(std::make_pair(key, value));
        }
    }
    {
        int pack;
        stream >> pack;
        e = static_cast<TestEnum>(e);
    }
    {
        std::string pack;
        stream >> pack;
        type.from_string(pack);
    }
}

void Poo::from_json(const std::string& json)
{
}

std::string Poo::to_json() const
{
    reflect::encoding::StringBuffer buffer;
    buffer.push_line("{");
    // Parent class Foo properties
    buffer.push_line("    \"a\": ", a, ",");
    buffer.push_line("    \"b\": ", b, ",");
    buffer.push_line("    \"enabled\": ", enabled ? "true" : "false", ",");
    // Properties
    buffer.push_line("    \"c\": ", c, ",");
    buffer.push_line("    \"e\": ", "\"", enumToString(e), "\"", ",");
    buffer.push_line("}");
    return buffer.string();
}

const reflect::meta_t& reflect::Type<Too>::meta()
{
    static reflect::meta_t s_meta {
    };
    return s_meta;
}
const char* const reflect::Type<Too>::name() { return "Too"; }

const reflect::properties_t& Type<Too>::properties()
{
    static reflect::properties_t s_properties {
        // Parent class Foo properties
        { "a", reflect::Property{ offsetof(Too, a), reflect::meta_t {{"JsonExport", "true"} }, "a", reflect::NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int } } },
        { "b", reflect::Property{ offsetof(Too, b), reflect::meta_t { }, "b", reflect::NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int } } },
        { "enabled", reflect::Property{ offsetof(Too, enabled), reflect::meta_t { }, "enabled", reflect::NativeType{ "bool", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(bool), reflect::NativeType::Type::T_bool } } },
        // Properties
        { "c", reflect::Property{ offsetof(Too, c), reflect::meta_t { }, "c", reflect::NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int } } },
    };
    return s_properties;
}

const reflect::meta_t& Too::type_meta() const { return reflect::Type<Too>::meta(); }
const char* const Too::type_name() const { return reflect::Type<Too>::name(); }
const reflect::properties_t& Too::type_properties() const { return reflect::Type<Too>::properties(); }

Too::operator std::string() const
{
    reflect::encoding::ByteBuffer buffer;
    reflect::encoding::OutputByteStream stream(buffer);
    stream << type_name();
    
    // Parent class Foo properties
    stream << a;
    stream << b;
    stream << enabled;
    // Properties
    stream << c;
    
    return std::string(reinterpret_cast<const char*>(&stream.getBuffer()[0]), stream.getBuffer().size());
}

void Too::from_string(const std::string& str)
{
    reflect::encoding::ByteBuffer buffer;
    std::transform(
        std::begin(str),
        std::end(str),
        std::back_inserter(buffer),
        [](const char c)
        {
            return std::byte(c);
        }
    );
    
    reflect::encoding::InputByteStream stream(buffer);
    std::string _name;
    stream >> _name;
    if (_name != type_name()) return;
    
    // Parent class Foo properties
    stream >> a;
    stream >> b;
    stream >> enabled;
    // Properties
    stream >> c;
}

void Too::from_json(const std::string& json)
{
}

std::string Too::to_json() const
{
    reflect::encoding::StringBuffer buffer;
    buffer.push_line("{");
    // Parent class Foo properties
    buffer.push_line("    \"a\": ", a, ",");
    buffer.push_line("    \"b\": ", b, ",");
    buffer.push_line("    \"enabled\": ", enabled ? "true" : "false", ",");
    // Properties
    buffer.push_line("    \"c\": ", c, ",");
    buffer.push_line("}");
    return buffer.string();
}

