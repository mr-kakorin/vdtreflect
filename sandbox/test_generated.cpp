// Copyright (c) Vito Domenico Tagliente
// automatically generated by the compiler, do not modify
#include "test.h"

const char* const reflect::Enum<TestEnum>::name() { return "TestEnum"; }
const reflect::enum_values_t& reflect::Enum<TestEnum>::values()
{
    static reflect::enum_values_t s_values{
        { "A", static_cast<int>(TestEnum::A) }, 
        { "B", static_cast<int>(TestEnum::B) }, 
    };
    return s_values;
}

const char* const reflect::Enum<ApplicationMode>::name() { return "ApplicationMode"; }
const reflect::enum_values_t& reflect::Enum<ApplicationMode>::values()
{
    static reflect::enum_values_t s_values{
        { "Editor", static_cast<int>(ApplicationMode::Editor) }, 
        { "Server", static_cast<int>(ApplicationMode::Server) }, 
        { "Standalone", static_cast<int>(ApplicationMode::Standalone) }, 
    };
    return s_values;
}

const reflect::meta_t& reflect::Type<Foo>::meta()
{
    static reflect::meta_t s_meta {
        { "Category", "MyClass" },
        { "Serializable", "true" },
    };
    return s_meta;
}
const char* const reflect::Type<Foo>::name() { return "Foo"; }

const reflect::properties_t& Type<Foo>::properties()
{
    static reflect::properties_t s_properties {
        { "a", reflect::Property{ offsetof(Foo, a), reflect::meta_t {{"JsonExport", "true"} }, "a", NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int } } },
        { "b", reflect::Property{ offsetof(Foo, b), reflect::meta_t { }, "b", NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int } } },
    };
    return s_properties;
}

const reflect::meta_t& Foo::type_meta() const { return reflect::Type<Foo>::meta(); }
const char* const Foo::type_name() const { return reflect::Type<Foo>::name(); }
const reflect::properties_t& Foo::type_properties() const { return reflect::Type<Foo>::properties(); }

const reflect::meta_t& reflect::Type<Poo>::meta()
{
    static reflect::meta_t s_meta {
    };
    return s_meta;
}
const char* const reflect::Type<Poo>::name() { return "Poo"; }

const reflect::properties_t& Type<Poo>::properties()
{
    static reflect::properties_t s_properties {
        // Parent class Foo properties
        { "a", reflect::Property{ offsetof(Poo, a), reflect::meta_t {{"JsonExport", "true"} }, "a", NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int } } },
        { "b", reflect::Property{ offsetof(Poo, b), reflect::meta_t { }, "b", NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int } } },
        // Properties
        { "c", reflect::Property{ offsetof(Poo, c), reflect::meta_t { }, "c", NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int } } },
        { "numbers", reflect::Property{ offsetof(Poo, numbers), reflect::meta_t { }, "numbers", NativeType{ "std::vector<int>", { 
            NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int },
        }, reflect::NativeType::DecoratorType::D_raw, sizeof(std::vector<int>), reflect::NativeType::Type::T_template } } },
        { "dictionary", reflect::Property{ offsetof(Poo, dictionary), reflect::meta_t { }, "dictionary", NativeType{ "std::map<std::string, int>", { 
            NativeType{ "std::string", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(std::string), reflect::NativeType::Type::T_string },
            NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int },
        }, reflect::NativeType::DecoratorType::D_raw, sizeof(std::map<std::string, int>), reflect::NativeType::Type::T_template } } },
        { "tuple", reflect::Property{ offsetof(Poo, tuple), reflect::meta_t { }, "tuple", NativeType{ "std::tuple<int, float, bool, double>", { 
            NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int },
            NativeType{ "float", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(float), reflect::NativeType::Type::T_float },
            NativeType{ "bool", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(bool), reflect::NativeType::Type::T_bool },
            NativeType{ "double", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(double), reflect::NativeType::Type::T_double },
        }, reflect::NativeType::DecoratorType::D_raw, sizeof(std::tuple<int, float, bool, double>), reflect::NativeType::Type::T_template } } },
        { "power_dictionary", reflect::Property{ offsetof(Poo, power_dictionary), reflect::meta_t { }, "power_dictionary", NativeType{ "std::map<std::string, std::vector<int>>", { 
            NativeType{ "std::string", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(std::string), reflect::NativeType::Type::T_string },
            NativeType{ "std::vector<int>", { 
                NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int },
            }, reflect::NativeType::DecoratorType::D_raw, sizeof(std::vector<int>), reflect::NativeType::Type::T_template },
        }, reflect::NativeType::DecoratorType::D_raw, sizeof(std::map<std::string, std::vector<int>>), reflect::NativeType::Type::T_template } } },
        { "e", reflect::Property{ offsetof(Poo, e), reflect::meta_t { }, "e", NativeType{ "TestEnum", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(TestEnum), reflect::NativeType::Type::T_enum } } },
        { "type", reflect::Property{ offsetof(Poo, type), reflect::meta_t { }, "type", NativeType{ "Foo", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(Foo), reflect::NativeType::Type::T_type } } },
    };
    return s_properties;
}

const reflect::meta_t& Poo::type_meta() const { return reflect::Type<Poo>::meta(); }
const char* const Poo::type_name() const { return reflect::Type<Poo>::name(); }
const reflect::properties_t& Poo::type_properties() const { return reflect::Type<Poo>::properties(); }

const reflect::meta_t& reflect::Type<Too>::meta()
{
    static reflect::meta_t s_meta {
    };
    return s_meta;
}
const char* const reflect::Type<Too>::name() { return "Too"; }

const reflect::properties_t& Type<Too>::properties()
{
    static reflect::properties_t s_properties {
        // Parent class Foo properties
        { "a", reflect::Property{ offsetof(Too, a), reflect::meta_t {{"JsonExport", "true"} }, "a", NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int } } },
        { "b", reflect::Property{ offsetof(Too, b), reflect::meta_t { }, "b", NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int } } },
        // Properties
        { "c", reflect::Property{ offsetof(Too, c), reflect::meta_t { }, "c", NativeType{ "int", {  }, reflect::NativeType::DecoratorType::D_raw, sizeof(int), reflect::NativeType::Type::T_int } } },
    };
    return s_properties;
}

const reflect::meta_t& Too::type_meta() const { return reflect::Type<Too>::meta(); }
const char* const Too::type_name() const { return reflect::Type<Too>::name(); }
const reflect::properties_t& Too::type_properties() const { return reflect::Type<Too>::properties(); }

